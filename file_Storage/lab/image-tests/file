at first build the securityConfigure:
	@EnableWebSecurity
	@EnableMethodSecurity(securedEnabled = true)
	public class SecurityConfig {}

then build the securityFilterChain bean:
	@Bean
    	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
       		http
                .cors(withDefaults())
                .csrf(csrfConfigurer->csrfConfigurer.disable())
                .authorizeHttpRequests(auth->
                        auth.requestMatchers("/auth/**")
                                .permitAll()
                                .anyRequest()
                                .authenticated()
                )
                .sessionManagement(session ->
                        session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .authenticationProvider(authenticationProvider)
                .addFilterBefore(jwtAuthFilter,UsernamePasswordAuthenticationFilter.class);
    	    return http.build();
    	}
    	
    				--------------
from the prvious i need authenticantion provider, jwtFilter so i need to build appConfigure
and JwtFilter:
	@Configuration
	public class Appconfig {}
	
	
then in it build ur aut provider
	@Bean
    	AuthenticationProvider authenticationProvider(){
		DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();
		daoAuthenticationProvider.setUserDetailsService(userDetailsService());
		daoAuthenticationProvider.setPasswordEncoder(passwordEncoder());
		return daoAuthenticationProvider;
    	}

from the previous i need userDetailsService(), and passwordEncoder():
 	@Bean
    	public UserDetailsService userDetailsService() {
		return (username) ->
		        userRepository.findByEmail(username).orElseThrow(()->new 
		        UsernameNotFoundException("user not found"));
    	}
    	
    	@Bean
    	public PasswordEncoder passwordEncoder(){
        	return new BCryptPasswordEncoder();
    	}
    	
and last thin i authenticationManager to manage the auth proccess:
	@Bean
    	AuthenticationManager authenticationManager(AuthenticationConfiguration conf) throws Exception 
    	{
        	return conf.getAuthenticationManager();
    	}
    	
    				--------------
		        
then create jwtFilter 
	(
	  do 2 functions 1- is to get the user details from db. 
	  		 2- is to validate the jwt in the jwtService by
	  checking:
	 	(expiration date and the user details from db using date(unique value to search by)
	 	 extracted from token
	 	 against user details from the token it self)
	 	by delegating this checking to the jwt service.
	)
	
to do 1 i need{ 
  	1- userEmail and i can get it from
  	2- JWT, and i can find it in
  	3- authHeader
  	so:
  	String authHeader = request.getHeader("Authorization");
        String jwt;
        String userEmail;

        if (authHeader == null || !authHeader.startsWith("Bearer ")){
            filterChain.doFilter(request,response);
            return;
        }
        jwt = authHeader.substring(7);
        userEmail = JwtService.extractUserEmail(jwt);
        }
to do 2 i need{}
        			--------------			
        
create the Jwt service
	(it 1- generates new tokens. 2- check token validation. 3-extract claim from claims)
	to validate the token 2 here and 2 in the create jwtFilter
		public boolean isTokenValid(String token,UserDetails userDetails){}
		
	i need to check: 1-user deateils from parameter, user details from db
	
	so i need userEmail to get the user details from db
	so i will extract it from the token
		public boolean isTokenValid(String token,UserDetails userDetails){
     		   String userEmail = extractUserEmail(token);
    		}
		
		will delegate to:
		public String extractUserEmail(String token) {
        		return extractSpecificClaim(token,claims->claims.getSubject());
   		}
   		
   		will delegate to generic cxtraction method:
   		private <T> T extractSpecificClaim(String token, Function<Claims,T>specificClaim) {
        		Claims claims = extractAllClaims(token);
        		return specificClaim.apply(claims);
    		}
    		
    		will get all from:
    		private Claims extractAllClaims(String token) {
        	return Jwts
			.parserBuilder()
			.setSigningKey(getSignInKey())
			.build().
			parseClaimsJws(token)
			.getBody();
    		}		
	
			2-expriation date
			
	so i need expiration date from the jwt
		private boolean isTokenExpired(String token) {
        		return extractEpiration(token).before(new Date());
    		}
    		
    		will delegate to:
    		private Date extractEpiration(String token) {
			return extractSpecificClaim(token,claims -> claims.getExpiration());
		}

	now i ready to validate the token:
		public boolean isTokenValid(String token,UserDetails userDetails){
			String userEmail = extractUserEmail(token);
			return (userEmail.equals(userDetails.getUsername()) &&	
			!isTokenExpired(token));
   		 }
   		 
   		--------------------so lets go back to jwtFilter-------------
   		
now i have the user email and i can validate it:  
	to validate i want to know if thereis a userEmail, and if the user is not in the context 
	holder:
	if(userEmail !=null && SecurityContextHolder.getContext().getAuthentication()==null){}
	
	then load the user details:
	UserDetails userDetails = userDetailsService.loadUserByUsername(userEmail);
	
	now u can validate:
	if(jwtService.isTokenValid(jwt,userDetails)){}
	
	and if it valid update the context holder with token:
	 UsernamePasswordAuthenticationToken auth=new UsernamePasswordAuthenticationToken(
                  userDetails,
                  null,
                  userDetails.getAuthorities()
         );
         auth.setDetails(
                     new WebAuthenticationDetailsSource().buildDetails(request)
         );
           SecurityContextHolder.getContext().setAuthentication(auth);
         }	
         
         then finis the filter:
		filterChain.doFilter(request,response);





























